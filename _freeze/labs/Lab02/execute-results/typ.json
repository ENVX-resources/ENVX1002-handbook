{
  "hash": "f5a5988110dd7a306ff48d0641f4878e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Lab 02 -- Statistical programming\nembed-resources: true\nresources:\n  - data/soil.xlsx\n  - data/mario_kart.csv\n---\n\n\n\n\n\n\n\n\n::: {.callout-tip}\n## Learning Outcomes\n\nAt the end of this practical students should be able to:\n\n- Acknowledge the importance of academic integrity\n- Import, subset and inspect data in R\n- Calculate simple summary statistics using both R and Excel\n- Generate dynamic reports in Quarto using inline R code\n- Understand how to debug R code\n:::\n\n## Before we begin\nPlease create a new Quarto document in your project folder to practice R code and complete lab exercises. We will go through the process in Exercise 1.\n\nThe following packages are required for this practical:\n\n- `tidyverse` -- a collection of R packages designed for data science\n- `readxl` -- a package for reading Excel files\n- `modeest` -- a package for estimating the mode of a distribution\n- `lubridate` -- a package for working with dates and times\n\nIf you have not already installed these packages, you can do so by adding the following code into a code chunk in your Quarto document:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(modeest)\nlibrary(lubridate)\n```\n:::\n\n\n\n\n\n\nFinally, please download the data file used in this lab here: [soil.xlsx](data/soil.xlsx).\n\n## Academic integrity\n\nThis exercise encourages students to discuss academic integrity, and in particular the grey areas often present. Your demonstrator will provide you with a number of scenarios to discuss with each other in smaller groups, and then with the class. \n\nIf you are interested in more information on Academic Integrity at the University of Sydney, see the following link: [Academic Integrity](https://www.sydney.edu.au/students/academic-integrity.html). Also ensure you have completed the Academic Honesty Education Module (AHEM). This must be complete before your first assessment is due (next week for ENVX1002). \n\n## Exercise 1: Setting up (walk-through)\n\n### Getting Started - Important!\n\nBefore starting each lab session, you will need to create a new Quarto document to work on the exercises. Follow these steps to set up your lab environment:\n\n1. **Open RStudio Project**\n   - Any of the following should work:\n     a. In RStudio, click on the project name in the top-right corner and select your project from a recent list. (It might already be open, otherwise it would show \"Project: (None)\")\n     b. In RStudio, use File > Open Project to navigate to your `.Rproj` file\n     c. Double-click the `.Rproj` file directly from your file explorer\n\n::: {.column-margin}\nYour project name should appear in the top-right corner of RStudio.\n:::\n\n2. **Create a New Quarto Document**\n   - Several ways to do it, the easiest is by clicking the \"New File\" button in the toolbar and selecting \"Quarto Document...\"\n   - Give your document a meaningful name (e.g., `Lab 2 Exercises`), leave other options as default and click \"Create\"\n\n3. **Save and Render Your Document**\n   - **You must save your document now.** This acts as a simple check to see that you are working in an environment that is not restricted.\n   - Click File > Save or press Ctrl+S (Windows) / Cmd+S (Mac)\n   - Name it something meaningful like `lab02_practice.qmd`\n   - Click the \"Render\" button in the editor toolbar to generate the HTML output\n\n::: {.callout-note}\nIf you encounter any issues, please ask your demonstrator for help.\n:::\n\n### Follow our lead\n\n::: callout-important\nWe've created this section to make sure you don't get lost during the lab. Remember to read \"A brief R guide for surviving ENVX1002\" available in the Tool Kit section on Canvas for a better understanding of how to use R in this course.\n:::\n\n\n#### Two golden rules\n\n1. Text are formatted in Markdown (like this text)\n2. Code must be written inside code chunks \n\nA code chunk is what makes your document \"dynamic\" as it can execute code and perform all sorts of tasks. \n\nTo create a code chunk:\n\n- **Quick way**: Use keyboard shortcuts\n  - Windows/Linux: `Ctrl + Alt + I`\n  - Mac: `Cmd + Option + I`\n- **Manual way**: Type three backticks followed by {r}, then end with three backticks\n\nHere's what a code chunk looks like:\n\n```{{r}}\nmean(c(1, 2, 3))\n```\nNote: the \"fence\" that we use (the three backticks plus the `{r}`) will only be visible in Source view. Your demonstrator will show you how to switch between Source and Preview views.\n\n\n#### Understanding Functions\n\nThis is a function:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Input → Process → Output\nmean(c(2, 4, 6)) # Takes numbers, calculates average, returns 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\n\n\n\nYou can recognise it because it has:\n\n- A name (`mean`)\n- Parentheses `()` to hold input data\n- Input data inside the parentheses (e.g., `c(2, 4, 6)`)\n\nA function will almost always return an output, which you can use in your code. In this case, the output is `4`. Functions are the reason why we can do so much with R -- they are like actions that someobe else has written for us to use so that we can complete our tasks with minimal programming.\n\nLet's look at three common functions for central tendency, but at the same time look at what it means to run functions on data we often call \"objects\":\n\n1. `mean()`: \n\n\n\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   # Create a vector of numbers and store it in an object called \"scores\"\n   scores <- c(85, 92, 78, 95, 8)\n   # Calculate the mean of the scores\n   mean(scores)\n   ```\n   \n   ::: {.cell-output .cell-output-stdout}\n   \n   ```\n   [1] 71.6\n   ```\n   \n   \n   :::\n   :::\n\n\n\n\n\n\n2. `median()`: \n\n\n\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   heights <- c(160, 165, 168, 170, 185)\n   median(heights)\n   ```\n   \n   ::: {.cell-output .cell-output-stdout}\n   \n   ```\n   [1] 168\n   ```\n   \n   \n   :::\n   :::\n\n\n\n\n\n\n3. `mode()`:\n\n\n\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   votes <- c(\"yes\", \"no\", \"yes\", \"maybe\", \"yes\")\n   mfv(votes)\n   ```\n   \n   ::: {.cell-output .cell-output-stdout}\n   \n   ```\n   [1] \"yes\"\n   ```\n   \n   \n   :::\n   :::\n\n\n\n\n\n\nRemember: Every function needs:\n\n- Parentheses `()` to work\n- Input data (inside the parentheses)\n- Sometimes extra options (like `na.rm = TRUE` to handle missing values)\n\n\n## Exercise 2: Water quality\n\nSulphate (SO~4~) is a key indicator in water quality monitoring and can be used to assess environmental impacts from industry and agriculture. In this exercise, we will explore a dataset of SO~4~ concentrations (mg/kg) in water samples.\n\nThe data is stored in a sheet called \"SO4\" in the MS Excel file, `soil.xlsx`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nso4 <- read_excel(\"data/soil.xlsx\", sheet = \"SO4\")\n```\n:::\n\n\n\n\n\n\n\n::: {.column-margin}\nTry writing and running the code chunks in your own Quarto document to see their outputs. Results will appear below each chunk. See Lab 01 for more information on inserting and running code chunks in Quarto.\n:::\n\nWhen we load data into R for the first time, it is important to check what it looks like (and whether it loaded correctly). The `str()` function is a good way to quickly inspect the data:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(so4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [39 × 1] (S3: tbl_df/tbl/data.frame)\n $ SO4: num [1:39] 50.6 55.4 56.5 57.5 58.3 63 66.5 64.5 63.4 58.4 ...\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.callout-tip}\n## Question 1\n**What does the output of `str()` tell us about the data?** You may want to look at the documentation `?str` or search online for more information, but ask your demonstrator if you're still unsure about why we use this function. Relate this to the data you are working with.\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-warning}\n## Answer 1\nThe `str()` function provides a concise summary of the data frame structure. It tells us the number of observations (rows) and variables (columns), as well as the data type of each variable. This is useful for understanding the data we are working with. For this particular dataset, we see that it contains 30 observations of one variable, `SO4`, which is a numeric variable inside a `tibble` object. All this can be inferred from the output of `str()`:\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [39 × 1] (S3: tbl_df/tbl/data.frame)\n $ SO4: num [1:39] 50.6 55.4 56.5 57.5 58.3 63 66.5 64.5 63.4 58.4 ...\n```\n\n\n:::\n:::\n\n\n\n\n\n\n:::\n:::\n\nSince the data is a data frame object, we have a good idea of what functions we can use to explore it.\nLet's examine the first few rows of our data:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(so4)\n```\n:::\n\n\n\n\n\n\n\nLet's calculate some basic descriptive statistics. Read the code and try to understand every part of it, including the text in `#`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate mean, median, and mode\nmean_so4 <- mean(so4$SO4)\nmedian_so4 <- median(so4$SO4)\nmode_so4 <- mfv(so4$SO4)[1] # Most frequent value using modeest package\n\n# Calculate measures of spread\nrange_so4 <- range(so4$SO4)\niqr_so4 <- IQR(so4$SO4)\nvar_so4 <- var(so4$SO4)\nsd_so4 <- sd(so4$SO4)\n```\n:::\n\n\n\n\n\n\n### Reporting your data\n\nWhen reporting statistics in a Quarto document, there are two approaches we could take:\n\n#### 1. Basic R output:\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_so4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 61.92308\n```\n\n\n:::\n\n```{.r .cell-code}\nsd_so4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5.241558\n```\n\n\n:::\n\n```{.r .cell-code}\nmedian_so4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 62.1\n```\n\n\n:::\n:::\n\n\n\n\n\n\n#### 2. Inline reporting (recommended):\n\nConsider the following reporting:\n\n> The mean SO~4~ concentration in our samples is 61.92 mg/kg, with a standard deviation of 5.24 mg/kg. The median value is 62.1 mg/kg.\n\nUsing inline R code (approach 2) has several advantages:\n\n- Statistics are seamlessly integrated into your text\n- Numbers are automatically updated if your data changes\n- Results are presented in a reader-friendly format\n\nTo create inline R code, use backticks with r, like this:\n\n```markdown\nThe mean SO~4~ concentration in our samples is `{{r}} round(mean_so4, 2)` mg/kg...\n```\n\nTry to recreate the report above in your Quarto document, or use other objects like `mode_so4` and `var_so4` in your report.\n\n\n## Exercise 3: Using MS Excel\n\nWhy use Excel when you have R? Well, Excel is an ubiquitous tool in many industries and can be a useful complement to R for quick data exploration and analysis. Sometimes it may even be easier to use Excel for simple tasks. \n\nLet's calculate the same statistics using Excel to compare approaches. First:\n\n1. Open the `soil.xlsx` file in Excel\n2. Navigate to the \"SO4_excel\" sheet (we'll use this sheet to avoid modifying the original data)\n3. Ensure the data is properly displayed in columns\n\n\n:::{.column-margin}\nMS Excel remains a popular tool for quick and dirty data analysis and can be a valuable resource in just about any field.\n:::\n\n![Imported data in Excel. Make sure to use the \"SO4_excel\" sheet.](images/excel-data.png)\n\nFor any calculation in Excel:\n\n1. Select an empty cell\n2. Type \"`=`\" followed by the function name\n3. Select your data range\n4. Press Enter\n\nFor example, to calculate the mean:\n\n1. Click an empty cell\n2. Type `=AVERAGE(`\n3. Select all SO4 values\n4. Type `)` and press Enter\n\n![Using the `=AVERAGE()` formula in Excel. Note that this screenshot demonstrates the selection of a specific range of data.](images/excel-mean-formula.png)\n\n::: {.callout-tip}\n## Question 2\nCalculate these statistics for the SO~4~ data in Excel:\n\n- For central tendency:\n  - Mean: Use `=AVERAGE()`\n  - Median: Use `=MEDIAN()`\n  - Mode: Use `=MODE()`\n- For spread:\n  - Range: Use `=MAX()` and `=MIN()`\n  - IQR: Use `=QUARTILE.INC()` for Q3 and Q1\n  - Variance: Use `=VAR.S()`\n  - Standard Deviation: Use `=STDEV.S()`\n\n\nWrite notes on how you used these formulas if necessary. You may also want to compare the results with those obtained in R and write down your thoughts on the efficiency and ease of use for each method.\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-warning}\n## Answer 2\nThis exercise should be straightforward. Ask your demonstrator if you encounter any issues.\n:::\n:::\n\n\n## Exercise 4: Soil data\n\nIn agricultural science, soil characteristics are essential for understanding soil health and fertility. The `soil` sheet in the `soil.xlsx` file contains data on soil properties at different depths, as well as lithology and land use information.\n\nIn this exercise, we'll explore different ways to subset data in R using the soil characteristics data. First, let's load the data:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoil <- read_excel(\"data/soil.xlsx\", sheet = \"soil\")\n```\n:::\n\n\n\n\n\n\n### Understanding data structure\nLet's examine our data structure:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(soil)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ntibble [55 × 7] (S3: tbl_df/tbl/data.frame)\n $ id       : chr [1:55] \"AT1\" \"AT2\" \"AT3\" \"BM1\" ...\n $ clay0    : num [1:55] 21.26 21.43 4.52 19.37 40.64 ...\n $ clay60   : num [1:55] 30.4 38.2 42.6 24.6 75.6 ...\n $ ec0      : num [1:55] 52.4 34.9 52.8 35.1 46.4 ...\n $ ec60     : num [1:55] 32.6 25.1 38.5 26.4 35.2 ...\n $ lithology: chr [1:55] \"Siliceous Mid\" \"Siliceous Mid\" \"Siliceous Lower\" \"Siliceous Lower\" ...\n $ land_use : chr [1:55] \"Grazing\" \"Grazing\" \"Grazing\" \"Grazing\" ...\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(soil)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 7\n  id    clay0 clay60   ec0  ec60 lithology       land_use\n  <chr> <dbl>  <dbl> <dbl> <dbl> <chr>           <chr>   \n1 AT1   21.3    30.4  52.4  32.6 Siliceous Mid   Grazing \n2 AT2   21.4    38.2  34.8  25.1 Siliceous Mid   Grazing \n3 AT3    4.52   42.6  52.8  38.5 Siliceous Lower Grazing \n4 BM1   19.4    24.6  35.2  26.4 Siliceous Lower Grazing \n5 BM2   40.6    75.6  46.4  35.2 Mafic           Grazing \n6 BM3   42.7    75.1  50.0  59.7 Mafic           Grazing \n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.callout-tip}\n## Question 3\n**What do you notice about the data structure that is different from the SO~4~ data?** How does this affect the way we subset the data?\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-warning}\n## Answer 3\nFrom `str()` we can observe that the `soil` data frame contains multiple columns, each representing a different soil property. This means we can subset the data based on different variables, such as clay content, electrical conductivity, lithology, and land use. The `head()` function shows the first few rows of the data, which can help us understand the data structure and content.\n:::\n:::\n\nThe `soil` data frame contains the following columns:\n  \n- `clay0`: Clay content at 0 cm depth\n- `clay60`: Clay content at 60 cm depth\n- `ec0`: Electrical conductivity at 0 cm depth\n- `ec60`: Electrical conductivity at 60 cm depth\n- `lithology`: Type of soil composition\n- `land_use`: Land usage type\n\n### Basic subsetting in R\n\nThere are two main ways to subset data in R:\n\n1. Using the `$` operator to select columns\n2. Using square brackets `[]` to select rows and columns\n\n#### Using the $ operator\nThe `$` operator allows us to select a specific column from our data frame. For example:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get the land use column\nsoil$land_use\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Grazing\"  \"Grazing\"  \"Grazing\"  \"Grazing\"  \"Grazing\"  \"Grazing\" \n [7] \"Grazing\"  \"Grazing\"  \"Grazing\"  \"Grazing\"  \"Grazing\"  \"Grazing\" \n[13] \"Grazing\"  \"Grazing\"  \"Grazing\"  \"Grazing\"  \"Grazing\"  \"Grazing\" \n[19] \"Grazing\"  \"Grazing\"  \"Grazing\"  \"Grazing\"  \"Cropping\" \"Cropping\"\n[25] \"Cropping\" \"Cropping\" \"Grazing\"  \"Grazing\"  \"Grazing\"  \"Grazing\" \n[31] \"Grazing\"  \"Grazing\"  \"Cropping\" \"Cropping\" \"Cropping\" \"Grazing\" \n[37] \"Cropping\" \"Grazing\"  \"Grazing\"  \"Grazing\"  \"Cropping\" \"Grazing\" \n[43] \"Grazing\"  \"Grazing\"  \"Cropping\" \"Grazing\"  \"Grazing\"  \"Grazing\" \n[49] \"Grazing\"  \"Grazing\"  \"Natural\"  \"Natural\"  \"Grazing\"  \"Cropping\"\n[55] \"Cropping\"\n```\n\n\n:::\n:::\n\n\n\n\n\n\nCombined with functions, the `$` operator can be used to calculate statistics on specific columns. \n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate the mean clay content at 0 cm depth\nmean_clay0 <- mean(soil$clay0)\nmean_clay0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 23.198\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.column-margin}\nNotice how we saved the result of the `mean()` function in a new object `mean_clay0`. This is useful for storing results and using them later in your code (e.g. for inline reporting). However, it means that the result will not be displayed in the console unless you explicitly print it by typing `mean_clay0` again in a new line.\n:::\n\n::: {.callout-note}\nThe `$` operator is particularly useful when you want to:\n\n- Access a single column quickly\n- Use column values in calculations\n- Create plots with specific variables\n:::\n\n#### Using square brackets []\nSquare brackets allow more flexible subsetting using the format: `dataframe[rows, columns]`. It also works with vectors, lists, and matrices. Try the following examples:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoil[1:5, ] # First 5 rows, all columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 7\n  id    clay0 clay60   ec0  ec60 lithology       land_use\n  <chr> <dbl>  <dbl> <dbl> <dbl> <chr>           <chr>   \n1 AT1   21.3    30.4  52.4  32.6 Siliceous Mid   Grazing \n2 AT2   21.4    38.2  34.8  25.1 Siliceous Mid   Grazing \n3 AT3    4.52   42.6  52.8  38.5 Siliceous Lower Grazing \n4 BM1   19.4    24.6  35.2  26.4 Siliceous Lower Grazing \n5 BM2   40.6    75.6  46.4  35.2 Mafic           Grazing \n```\n\n\n:::\n\n```{.r .cell-code}\nsoil[, c(\"clay0\", \"clay60\")] # Clay columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 55 × 2\n   clay0 clay60\n   <dbl>  <dbl>\n 1 21.3    30.4\n 2 21.4    38.2\n 3  4.52   42.6\n 4 19.4    24.6\n 5 40.6    75.6\n 6 42.7    75.1\n 7 28.1    50.5\n 8 41.3    72.6\n 9 48.7    78.7\n10 26.3    50.5\n# ℹ 45 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nsoil[1:3, c(\"ec0\", \"ec60\")] # First 3 rows, electrical conductivity columns\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n    ec0  ec60\n  <dbl> <dbl>\n1  52.4  32.6\n2  34.8  25.1\n3  52.8  38.5\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.column-margin}\nWhen using `[]`, leaving the row or column section empty (with just a comma) means \"select all\"\n:::\n\n**Basic subsetting**: Use square brackets to extract soil samples at 0cm depth that have clay content greater than 40%.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoil[soil$clay0 > 40, ]\n```\n:::\n\n\n\n\n\n\n**Multiple conditions**: Find samples where clay content at 60cm is greater than 30% AND electrical conductivity at 0cm is less than 0.5.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoil[soil$clay60 > 30 & soil$ec0 < 0.5, ]\n```\n:::\n\n\n\n\n\n\n::: {.callout-tip}\n## Question 4\n**Practice**: Subset the data to find samples where:\n\n- clay content at 0cm depth is less than 50%\n- electrical conductivity at 60cm depth is between 25 and 30, inclusive\n- clay content at 0cm is less than 10% OR electrical conductivity at 60cm is greater than 25\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-warning}\n## Answer 4\n\nClay content at 0cm depth is less than 50%\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoil[soil$clay0 < 50, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 54 × 7\n   id    clay0 clay60   ec0  ec60 lithology          land_use\n   <chr> <dbl>  <dbl> <dbl> <dbl> <chr>              <chr>   \n 1 AT1   21.3    30.4  52.4  32.6 Siliceous Mid      Grazing \n 2 AT2   21.4    38.2  34.8  25.1 Siliceous Mid      Grazing \n 3 AT3    4.52   42.6  52.8  38.5 Siliceous Lower    Grazing \n 4 BM1   19.4    24.6  35.2  26.4 Siliceous Lower    Grazing \n 5 BM2   40.6    75.6  46.4  35.2 Mafic              Grazing \n 6 BM3   42.7    75.1  50.0  59.7 Mafic              Grazing \n 7 BM4   28.1    50.5  66.9  47.6 Mafic              Grazing \n 8 BS1   41.3    72.6 100.  396.  Intermediate Lower Grazing \n 9 BS2   48.7    78.7  83.3 447.  Intermediate Lower Grazing \n10 C1    26.3    50.5  80.2  39.8 Mafic              Grazing \n# ℹ 44 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n\nElectrical conductivity at 60cm depth is between 25 and 30, inclusive\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoil[soil$ec60 >= 25 & soil$ec60 <= 30, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 7\n  id    clay0 clay60   ec0  ec60 lithology       land_use\n  <chr> <dbl>  <dbl> <dbl> <dbl> <chr>           <chr>   \n1 AT2   21.4    38.2  34.8  25.1 Siliceous Mid   Grazing \n2 BM1   19.4    24.6  35.2  26.4 Siliceous Lower Grazing \n3 HEN1  11.0    53.1  38.6  28.8 Siliceous Lower Grazing \n4 HEN4   9.65   56.2  29.5  28.6 Siliceous Lower Grazing \n5 JB3   30.8    48.2  57.2  27.2 Mafic           Cropping\n6 <NA>  NA      NA    NA    NA   <NA>            <NA>    \n7 ROM7  17.5    36.1  42.6  25.2 Siliceous Lower Grazing \n```\n\n\n:::\n:::\n\n\n\n\n\n\nClay content at 0cm is less than 10% OR electrical conductivity at 60cm is greater than 25\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsoil[soil$clay0 < 10 | soil$ec60 > 25, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 46 × 7\n   id    clay0 clay60   ec0  ec60 lithology          land_use\n   <chr> <dbl>  <dbl> <dbl> <dbl> <chr>              <chr>   \n 1 AT1   21.3    30.4  52.4  32.6 Siliceous Mid      Grazing \n 2 AT2   21.4    38.2  34.8  25.1 Siliceous Mid      Grazing \n 3 AT3    4.52   42.6  52.8  38.5 Siliceous Lower    Grazing \n 4 BM1   19.4    24.6  35.2  26.4 Siliceous Lower    Grazing \n 5 BM2   40.6    75.6  46.4  35.2 Mafic              Grazing \n 6 BM3   42.7    75.1  50.0  59.7 Mafic              Grazing \n 7 BM4   28.1    50.5  66.9  47.6 Mafic              Grazing \n 8 BS1   41.3    72.6 100.  396.  Intermediate Lower Grazing \n 9 BS2   48.7    78.7  83.3 447.  Intermediate Lower Grazing \n10 C1    26.3    50.5  80.2  39.8 Mafic              Grazing \n# ℹ 36 more rows\n```\n\n\n:::\n:::\n\n\n\n\n\n:::\n:::\n\n## Exercise 5: Soil statistics\n\nWe will continue to work on the soil dataset and practice calculating some basic summary statistics.\n\n::: {.callout-tip}\n## Question 5\n1. Calculate the mean, median, and mode for clay content at 0cm depth\n2. Calculate the range, IQR, variance, and standard deviation for electrical conductivity at 60cm depth\n3. Report these statistics in your Quarto document using inline R code\n:::\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-warning}\n## Answer 5\nNotice how in all the calculations, we used the `na.rm = TRUE` argument to handle missing values. This is important when calculating statistics to avoid errors.\n\n1. Calculate the mean, median, and mode for clay content at 60cm depth\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_clay0 <- mean(soil$clay60, na.rm = TRUE)\nmean_clay0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 46.63815\n```\n\n\n:::\n\n```{.r .cell-code}\nmedian_clay0 <- median(soil$clay60, na.rm = TRUE)\nmedian_clay0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 46.91\n```\n\n\n:::\n\n```{.r .cell-code}\nmode_clay0 <- mfv(soil$clay60, na.rm = TRUE)[1]\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nargument 'na.rm' is soft-deprecated, please start using 'na_rm' instead\n```\n\n\n:::\n\n```{.r .cell-code}\nmode_clay0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.38\n```\n\n\n:::\n:::\n\n\n\n\n\n\n2. Calculate the range, IQR, variance, and standard deviation for electrical conductivity at 60cm depth\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrange_ec60 <- range(soil$ec60, na.rm = TRUE)\nrange_ec60\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  15.86 446.72\n```\n\n\n:::\n\n```{.r .cell-code}\niqr_ec60 <- IQR(soil$ec60, na.rm = TRUE)\niqr_ec60\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 31.2675\n```\n\n\n:::\n\n```{.r .cell-code}\nvar_ec60 <- var(soil$ec60, na.rm = TRUE)\nvar_ec60\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5882.638\n```\n\n\n:::\n\n```{.r .cell-code}\nsd_ec60 <- sd(soil$ec60, na.rm = TRUE)\nsd_ec60\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 76.69836\n```\n\n\n:::\n:::\n\n\n\n\n\n\n3. Report these statistics in your Quarto document using inline R code\n\n```markdown\nThe mean clay content at 60cm depth is `{{r}} round(mean_clay0, 2)`%, with a median of `{{r}} round(median_clay0, 2)`% and a mode of `{{r}} mode_clay0`%. The range of electrical conductivity at 60cm depth is `{{r}} range_ec60[1]` to `{{r}} range_ec60[2]`, with an IQR of `{{r}} iqr_ec60`, variance of `{{r}} var_ec60`, and standard deviation of `{{r}} sd_ec60`.\n```\n:::\n:::\n\n\n## Done!\n\nThis is the end of Lab 02. Remember to save your Quarto document ~~and submit it to Canvas~~ when you're done. If you have any questions, feel free to ask your demonstrator for help.\n\n## Bonus: Take-home exercises\n\nTake-home exercises are optional but recommended for further practice. You can complete these exercises in your own time.\n\n### Exercise 5: Mario Kart statistics\n\nWe're not going to go too much about the game -- but here is a dataset of character attributes from the popular Mario Kart.\n\nDownload it here: [mario_kart.csv](data/mario_kart.csv)\n\nThe data is stored in a CSV file, which MS Excel can open directly. To read it into R, use the `read_csv()` function from the `readr` package.\n\nThe dataset contains the following variables:\n\n- `character`: Character name\n- `weight`: Character's weight class (1-5 scale)\n- `speed`: Maximum speed rating (1-5 scale)\n- `acceleration`: How quickly they reach top speed (1-5 scale)\n- `handling`: Steering control rating (1-5 scale)\n- `traction`: Grip on different surfaces (1-5 scale)\n- `drift_rating`: Skill at power-sliding around corners (1-5 scale)\n\n\nComplete the following exercises using both R and Excel:\n\n1. **Data Import and Inspection**\n   - Load the data into R using `read_csv()`\n   - Examine the structure using `str()`\n   - View the first few rows using `head()`\n   - What do you notice about the data?\n  \n2. **Central Tendency**\n   Calculate for the speed attribute:\n   - Mean\n   - Median\n   - Mode\n   \n   Which measure best represents the \"typical\" speed rating? Why?\n\n3. **Spread Analysis**\n   For the weight attribute, calculate:\n   - Range\n   - IQR\n   - Variance\n   - Standard deviation\n   \n   What do these tell you about the variation in character weights?\n\n4. **Character Comparison**\n   - Which characters have the highest and lowest acceleration?\n   - Find all characters with above-average handling\n   - Identify characters with both speed and weight above 4.0\n\n5. **Advanced Challenge**\n   - Calculate the mean of all attributes for each character\n   - Who is the most \"well-rounded\" character (closest to average in all stats)?\n   - Create a report comparing Mario and Luigi's stats using inline R code\n\n::: {.content-visible when-profile=\"solution\"}\n::: {.callout-warning}\n## Answer - Mario Kart Exercise\n\n### 1. Data Import and Inspection\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the data\nmario_kart <- read_csv(\"data/mario_kart.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 12 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): character\ndbl (6): weight, speed, acceleration, handling, traction, drift_rating\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\n# Examine structure\nstr(mario_kart)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nspc_tbl_ [12 × 7] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ character   : chr [1:12] \"Mario\" \"Luigi\" \"Peach\" \"Bowser\" ...\n $ weight      : num [1:12] 3.5 3.4 2.8 4.5 3 2.5 4.3 4.2 2.7 2.8 ...\n $ speed       : num [1:12] 4.2 4.1 3.8 4.5 4 3.7 4.4 4.3 3.6 3.8 ...\n $ acceleration: num [1:12] 3.8 3.9 4.2 2.8 4.1 4.4 2.9 3 4.3 4.2 ...\n $ handling    : num [1:12] 3.5 3.6 4 2.5 3.8 4.2 2.7 2.8 4.1 4 ...\n $ traction    : num [1:12] 3.7 3.8 3.5 3.2 3.9 3.6 3.3 3.4 3.7 3.6 ...\n $ drift_rating: num [1:12] 4 3.9 3.7 3.4 4.1 3.8 3.5 3.6 3.9 3.8 ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   character = col_character(),\n  ..   weight = col_double(),\n  ..   speed = col_double(),\n  ..   acceleration = col_double(),\n  ..   handling = col_double(),\n  ..   traction = col_double(),\n  ..   drift_rating = col_double()\n  .. )\n - attr(*, \"problems\")=<externalptr> \n```\n\n\n:::\n\n```{.r .cell-code}\n# View first few rows\nhead(mario_kart)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 7\n  character weight speed acceleration handling traction drift_rating\n  <chr>      <dbl> <dbl>        <dbl>    <dbl>    <dbl>        <dbl>\n1 Mario        3.5   4.2          3.8      3.5      3.7          4  \n2 Luigi        3.4   4.1          3.9      3.6      3.8          3.9\n3 Peach        2.8   3.8          4.2      4        3.5          3.7\n4 Bowser       4.5   4.5          2.8      2.5      3.2          3.4\n5 Yoshi        3     4            4.1      3.8      3.9          4.1\n6 Toad         2.5   3.7          4.4      4.2      3.6          3.8\n```\n\n\n:::\n:::\n\n\n\n\n\n\n**Observations about the data:**\n\n- The dataset contains 12 characters with 7 variables\n- All attributes except 'character' are numeric values on rating scales\n- Character names are stored as strings\n- The data appears to be clean with no missing values\n- Attributes are rated on scales that appear to range from approximately 2.5 to 4.5\n\n### 2. Central Tendency for Speed Attribute\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate mean speed\nmean_speed <- mean(mario_kart$speed)\nmean_speed\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.058333\n```\n\n\n:::\n\n```{.r .cell-code}\n# Calculate median speed\nmedian_speed <- median(mario_kart$speed)\nmedian_speed\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.1\n```\n\n\n:::\n\n```{.r .cell-code}\n# Calculate mode of speed\nmode_speed <- mfv(mario_kart$speed)[1]\nmode_speed\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.8\n```\n\n\n:::\n:::\n\n\n\n\n\n\n**Which measure best represents the \"typical\" speed rating?**\n\nThe median (4.1) is likely the best representation of the typical speed rating because:\n\n- It's not influenced by extreme values like the mean\n- The data shows a slight negative skew (more characters with higher speeds)\n- The median gives us the middle value that divides the characters evenly\n\n### 3. Spread Analysis for Weight Attribute\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate range\nrange_weight <- range(mario_kart$weight)\nrange_weight\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.5 4.5\n```\n\n\n:::\n\n```{.r .cell-code}\n# Calculate IQR\niqr_weight <- IQR(mario_kart$weight)\niqr_weight\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.25\n```\n\n\n:::\n\n```{.r .cell-code}\n# Calculate variance\nvar_weight <- var(mario_kart$weight)\nvar_weight\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.4844697\n```\n\n\n:::\n\n```{.r .cell-code}\n# Calculate standard deviation\nsd_weight <- sd(mario_kart$weight)\nsd_weight\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6960386\n```\n\n\n:::\n:::\n\n\n\n\n\n\n**What these tell us about variation in character weights:**\n\nThe weight attribute shows considerable variation:\n\n- Range: 2.5 to 4.5 (a spread of 2.0 units)\n- IQR: Approximately 1.1, indicating moderate spread in the middle 50% of characters\n- Standard deviation: Approximately 0.7, showing that weights typically vary by about 0.7 units from the mean\n- The distribution appears to be somewhat bimodal, with characters clustering around lighter weights (2.5-3.0) and heavier weights (4.0-4.5)\n\n### 4. Character Comparison\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Characters with highest and lowest acceleration\nmario_kart[which.max(mario_kart$acceleration), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 7\n  character weight speed acceleration handling traction drift_rating\n  <chr>      <dbl> <dbl>        <dbl>    <dbl>    <dbl>        <dbl>\n1 Toad         2.5   3.7          4.4      4.2      3.6          3.8\n```\n\n\n:::\n\n```{.r .cell-code}\nmario_kart[which.min(mario_kart$acceleration), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 7\n  character weight speed acceleration handling traction drift_rating\n  <chr>      <dbl> <dbl>        <dbl>    <dbl>    <dbl>        <dbl>\n1 Bowser       4.5   4.5          2.8      2.5      3.2          3.4\n```\n\n\n:::\n\n```{.r .cell-code}\n# Characters with above-average handling\nmean_handling <- mean(mario_kart$handling)\nmario_kart[mario_kart$handling > mean_handling, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 7\n  character      weight speed acceleration handling traction drift_rating\n  <chr>           <dbl> <dbl>        <dbl>    <dbl>    <dbl>        <dbl>\n1 Mario             3.5   4.2          3.8      3.5      3.7          4  \n2 Luigi             3.4   4.1          3.9      3.6      3.8          3.9\n3 Peach             2.8   3.8          4.2      4        3.5          3.7\n4 Yoshi             3     4            4.1      3.8      3.9          4.1\n5 Toad              2.5   3.7          4.4      4.2      3.6          3.8\n6 Koopa Troopa      2.7   3.6          4.3      4.1      3.7          3.9\n7 Princess Daisy    2.8   3.8          4.2      4        3.6          3.8\n```\n\n\n:::\n\n```{.r .cell-code}\n# Characters with both speed and weight above 4.0\nmario_kart[mario_kart$speed > 4.0 & mario_kart$weight > 4.0, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 7\n  character   weight speed acceleration handling traction drift_rating\n  <chr>        <dbl> <dbl>        <dbl>    <dbl>    <dbl>        <dbl>\n1 Bowser         4.5   4.5          2.8      2.5      3.2          3.4\n2 Wario          4.3   4.4          2.9      2.7      3.3          3.5\n3 Donkey Kong    4.2   4.3          3        2.8      3.4          3.6\n```\n\n\n:::\n:::\n\n\n\n\n\n\n**Results:**\n\n- Toad has the highest acceleration (4.4)\n- Bowser has the lowest acceleration (2.8)\n- Characters with above-average handling: Peach, Yoshi, Toad, Koopa Troopa, Princess Daisy\n- Characters with both speed and weight above 4.0: Bowser, Wario, Donkey Kong, Waluigi\n\n### 5. Advanced Challenge\n\nThis is an interesting question as it requires you to think through the idea of what it means to be \"closest to average\" in all stats -- hopefully many of you will see that it is a question about spread. In general, we want to find the character with the smallest deviation from the average across all attributes.\n\n**Our approach**:\n\n- First, we calculated each character's overall mean across all attributes (`overall_mean`)\n- Then, we found the global average of all attributes across all characters (`overall_avg`)\n- Next, we calculated how far each character's average is from this global average (`deviation`)\n- Finally, we selected the character with the smallest deviation as the most \"well-rounded\"\n\n**Why use deviation?**:\n\n- Deviation measures how far a value is from a reference point (in this case, the global average)\n- A small deviation indicates a character whose stats are close to the average\n- This aligns with our interpretation of \"well-rounded\" as being balanced and close to average\n- Using `which.min()` finds the character with the smallest deviation, identifying our most balanced character\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate mean of all attributes for each character\nmario_kart$overall_mean <- rowMeans(mario_kart[, c(\"weight\", \"speed\", \"acceleration\",\n                                                  \"handling\", \"traction\", \"drift_rating\")])\n\n# Find the most \"well-rounded\" character\n# First calculate the overall average across all characters and attributes\noverall_avg <- mean(unlist(mario_kart[, c(\"weight\", \"speed\", \"acceleration\",\n                                         \"handling\", \"traction\", \"drift_rating\")]))\n\n# Then find the character closest to this average\nmario_kart$deviation <- abs(mario_kart$overall_mean - overall_avg)\nwell_rounded <- mario_kart[which.min(mario_kart$deviation), ]\nwell_rounded\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 9\n  character weight speed acceleration handling traction drift_rating\n  <chr>      <dbl> <dbl>        <dbl>    <dbl>    <dbl>        <dbl>\n1 Peach        2.8   3.8          4.2        4      3.5          3.7\n# ℹ 2 more variables: overall_mean <dbl>, deviation <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n\n**Answer**: The most \"well-rounded\" character is Peach with an overall mean of 3.67.\n\n#### Alternative!\n\nThere isn't just one approach to this question! Another way to look at it is to, instead of calculating the deviation from the global average, calculate the sum of squared deviations from the average stats. This will give us a sense of how far each character's stats are from the average across all attributes.\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\navg_stats <- colMeans(mario_kart[, -1])\n\n# Calculate squared deviations for each character\ndeviations <- mario_kart |>\n  mutate(total_ss = (weight - avg_stats[\"weight\"])^2 + \n                    (speed - avg_stats[\"speed\"])^2 +\n                    (acceleration - avg_stats[\"acceleration\"])^2 +\n                    (handling - avg_stats[\"handling\"])^2 +\n                    (traction - avg_stats[\"traction\"])^2 +\n                    (drift_rating - avg_stats[\"drift_rating\"])^2) |>\n  arrange(total_ss)\ndeviations\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 10\n   character      weight speed acceleration handling traction drift_rating\n   <chr>           <dbl> <dbl>        <dbl>    <dbl>    <dbl>        <dbl>\n 1 Mario             3.5   4.2          3.8      3.5      3.7          4  \n 2 Luigi             3.4   4.1          3.9      3.6      3.8          3.9\n 3 King Boo          3.8   4.1          3.4      3.2      3.6          3.8\n 4 Yoshi             3     4            4.1      3.8      3.9          4.1\n 5 Waluigi           4     4.2          3.2      3        3.5          3.7\n 6 Princess Daisy    2.8   3.8          4.2      4        3.6          3.8\n 7 Peach             2.8   3.8          4.2      4        3.5          3.7\n 8 Donkey Kong       4.2   4.3          3        2.8      3.4          3.6\n 9 Koopa Troopa      2.7   3.6          4.3      4.1      3.7          3.9\n10 Toad              2.5   3.7          4.4      4.2      3.6          3.8\n11 Wario             4.3   4.4          2.9      2.7      3.3          3.5\n12 Bowser            4.5   4.5          2.8      2.5      3.2          3.4\n# ℹ 3 more variables: overall_mean <dbl>, deviation <dbl>, total_ss <dbl>\n```\n\n\n:::\n:::\n\n\n\n\n\n\n**Answer**: In this case, Mario is the most \"well-rounded\" character, with the smallest sum of squared deviations from the average stats.\n\n**Mario vs. Luigi Comparison Report:**\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Compare Mario and Luigi\nmario <- mario_kart[mario_kart$character == \"Mario\", ]\nluigi <- mario_kart[mario_kart$character == \"Luigi\", ]\n```\n:::\n\n\n\n\n\nMario and Luigi have similar stats, but with some notable differences:\n\n- **Weight**: Mario (3.5) is slightly heavier than Luigi (3.4)\n- **Speed**: Mario (4.2) is slightly faster than Luigi (4.1)\n- **Acceleration**: Luigi (3.9) has better acceleration than Mario (3.8)\n- **Handling**: Luigi (3.6) has better handling than Mario (3.5)\n- **Traction**: Luigi (3.8) has better traction than Mario (3.7)\n- **Drift Rating**: Mario (4) has a better drift rating than Luigi (3.9)\n\nOverall, Luigi tends to have better control stats (acceleration, handling, traction), while Mario has slightly better speed and drift capabilities.\n\n\n```markdown\nMario and Luigi have similar stats, but with some notable differences:\n\n- **Weight**: Mario (`{{r}} mario$weight`) is slightly heavier than Luigi (`{{r}} luigi$weight`)\n- **Speed**: Mario (`{{r}} mario$speed`) is slightly faster than Luigi (`{{r}} luigi$speed`)\n- **Acceleration**: Luigi (`{{r}} luigi$acceleration`) has better acceleration than Mario (`{{r}} mario$acceleration`)\n- **Handling**: Luigi (`{{r}} luigi$handling`) has better handling than Mario (`{{r}} mario$handling`)\n- **Traction**: Luigi (`{{r}} luigi$traction`) has better traction than Mario (`{{r}} mario$traction`)\n- **Drift Rating**: Mario (`{{r}} mario$drift_rating`) has a better drift rating than Luigi (`{{r}} luigi$drift_rating`)\n\nOverall, Luigi tends to have better control stats (acceleration, handling, traction), while Mario has slightly better speed and drift capabilities.\n```\n\n:::\n:::\n\n\n## Attribution\n\nThis lab document is licensed under a [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/). \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}